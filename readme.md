# Killer Game using AI generation only

**AI-Only Game Development Challenge**

<style>
.ai-response {
  border: 1px solid #e1e4e8;
  padding: 16px;
  border-radius: 6px;
  background-color: #f6f8fa;
  margin: 20px 0;
}
</style>

## Project description

<div  class="ai-response">

### üéØ The Mission

This project is a hands-on exploration of AI-assisted programming. The goal is to develop a fully functional game website where every line of code is generated by AI models. The key twist: the project management itself is also AI-driven.

### ü§ñ The Methodology

- **AI Project Manager:** One primary AI model (e.g., Claude 3, GPT-4) acts as the "PM." It is prompted to break down the project into sprints and generate detailed, context-aware prompts for other coding-specific AIs.

- **AI Developers:** Other models (e.g., DeepSeek Coder, CodeLlama, GPT-4) act as "developers," receiving prompts from the PM to write the actual code for front-end, back-end, and game logic.

- **Human Role:** I act as the **Supervising Engineer**. I relay prompts between models, manage context windows, integrate code snippets, and most importantly, **fact-check outputs to prevent cascading hallucinations**. I do not write any code or documentation myself.

### üß™ Objectives

- **Learn AI-Assisted Workflows:** Introduce myself to AI programming in its most fundamental form‚Äîraw prompt engineering.

- **Benchmark Models:** Conduct a non-scientific, practical comparison of leading AI models in both project management and coding roles.

- **Find the Limits:** Test how far a completely separated, human-managed AI system can go before it breaks down, requiring more integrated tools.

- **Build a Killer Game:** The ultimate success metric is a fun, publicly playable game.

### ‚ö†Ô∏è Disclaimer

This is an experimental benchmark, not a scientific one. Results are based on practical usability, code quality, and the ability to complete complex tasks, reflecting a real-world developer experience.

### Note

This readme, as all the documentation, is also Ai-generated (parts in code blocks).

</div>

## Game Specifications

Here are the project specifications obtained with the use of **DeepSeek**.

<div  class="ai-response">

# Project: "Killer" - Self-Hosted Party Game

## 1. Core Concept

A mobile-first web application for playing the "Killer" or "Assassin" social game. The game eliminates the need for a central human administrator by handling target assignment, kill claims, and verification automatically through a real-time website.

## 2. Technical Stack

- **Backend Runtime:** Node.js
- **Backend Framework:** Express.js
- **Real-Time Communication:** Socket.IO
- **Database:** SQLite with `better-sqlite3` driver
- **Frontend Framework:** SvelteKit (Static Adapter/SPA Mode)
- **Styling:** Pico.css (Lightweight CSS framework)
- **Process Manager:** PM2 (For keeping the app running)
- **Reverse Proxy & SSL:** Caddy (Recommended for simplicity)
- **Dynamic DNS (Optional):** DuckDNS or similar service

## 3. Key Features & User Flow

### A. Game Creation & Lobby

1.  **Creator Initializes Game:**

    - A player (creator) visits the homepage.
    - Inputs a list of all player names.
    - Inputs a list of custom tasks or selects default tasks.
    - Clicks "Create Game".
    - System generates a unique, shareable game code (e.g., `ABC123`) and URL (e.g., `https://myserver.com/play/ABC123`).

2.  **Players Join:**

    - Creator shares the URL.
    - Other players open the URL on their mobile devices.
    - They see the list of player names and must select/claim their own name.
    - Claiming a name generates a persistent `sessionToken` stored on their device, tying their identity to their browser.
    - The lobby view for the creator and all players updates in real-time to show who has joined.

3.  **Game Start:**
    - Once all players have joined, the creator clicks "Start Game".
    - The server algorithm creates a circular chain (derangement) of players.
    - Each player is randomly assigned a target and a task from the pool.
    - The game status changes from `lobby` to `active`.
    - All players' UIs update instantly to show their target and task.

### B. Main Gameplay

4.  **Player View (Mobile-First):**

    - Displays the player's current target name.
    - Displays the player's current task description.
    - Features a large, prominent "ELIMINATE TARGET" button.
    - Shows a real-time counter of alive players.

5.  **Kill Verification Process:**
    - **Claim:** Player A (Killer) clicks "ELIMINATE TARGET".
    - **Server Validation:** Server confirms Player A is alive and the target is still valid.
    - **Challenge:** A real-time notification is sent _specifically_ to Player B's (Target's) device. The notification is a modal that must be answered, stating: "_[Player A] claims they eliminated you by making you do: [Task Description]. Do you confirm?_"
    - **Resolution:**
      - **Confirm:** Player B clicks "CONFIRM". The server:
        - Marks Player B as `eliminated`.
        - Assigns Player B's target to Player A.
        - Updates the game state.
        - Notifies all players of the elimination and updates the alive counter.
        - Notifies Player A of their new target.
      - **Deny:** Player B clicks "DENY". The server notifies Player A that the kill was denied.

### C. Game State & End Game

6.  **Graveyard / Status Screen:**

    - A view accessible to all players listing all participants.
    - Clearly indicates who is alive and who is dead (e.g., with icons ‚ô•/‚ò†).
    - Updates in real-time as players are eliminated.

7.  **Game End:**
    - The server detects when only one player remains alive.
    - A notification is broadcast to all players declaring the winner.
    - An option to "View Elimination Chain" is provided, showing the sequence of kills.

## 4. Data Models (SQLite Tables)

- **Table: `games`**

  - `id` TEXT PRIMARY KEY (The public game code)
  - `creator_session` TEXT (Session ID of the game creator)
  - `status` TEXT ('lobby', 'active', 'completed')
  - `task_pool` TEXT (JSON string array of tasks for this game)
  - `created_at` DATETIME

- **Table: `players`**
  - `id` TEXT PRIMARY KEY (A UUID for each player)
  - `game_id` TEXT (Foreign key referencing `games.id`)
  - `name` TEXT
  - `session_token` TEXT (Unique token stored on the player's device)
  - `target_id` TEXT (Foreign key referencing `players.id` in the same game)
  - `assassin_id` TEXT (Foreign key referencing `players.id` - who is targeting this player)
  - `task` TEXT (The specific task assigned to this player)
  - `status` TEXT ('alive', 'eliminated')

## 5. Self-Hosting Infrastructure Setup

1.  **Machine:** A always-on computer (e.g., old laptop, Raspberry Pi) or a machine you can run during game sessions.
2.  **Networking:**
    - **Port Forwarding:** Configure your home router to forward ports 80 (HTTP) and 443 (HTTPS) to the local IP address of your server machine.
    - **Dynamic DNS (Optional):** Set up a DuckDNS (or similar) account to get a domain name that points to your home IP, as it may change.
3.  **Software on Server Machine:**
    - Install Node.js.
    - Install Caddy (reverse proxy) and configure it to point to your Node.js app's port (e.g., 3000) and handle SSL automatically.
    - Use PM2 to run your Node.js application as a background service that restarts automatically.

## 6. Critical Security & Logic Rules

- **Authentication:** A player's identity is solely determined by the `session_token` stored in their browser. All client requests must include this token.
- **Authorization (Server-Side Checks):**
  - A player can only claim a kill for their _own_ assigned target.
  - A player can only confirm/deny a kill claim made _against themselves_.
  - Players with status `eliminated` cannot perform any game actions.
- **State Management:** The server is the single source of truth. All game logic and state changes are validated and executed on the server before being broadcast to clients.

## 7. Non-Functional Requirements

- **Mobile-First UI:** The interface must be touch-friendly, responsive, and minimalist.
- **Real-Time Updates:** Must use WebSockets (via Socket.IO) for instant updates across all players' devices without requiring page refresh.
- **PWA:** Should be installable as a mobile app via a Service Worker and Web App Manifest.
- **Offline Functionality (Basic):** The app should cache necessary assets for reliable loading, though real-time features require online connectivity.

</div>

## Sprints

### Sprint 0: The Foundation Vibe

**AI used:** DeepSeek with DeepThinking

#### Setup

1. Clone this repository
2. Run the setup script: `./setup.sh` or `npm run setup`
3. Start the server: `npm start`
4. Open http://localhost:3000 in your browser

**Testing:** to run unit tests do steps 1. and 2. before running `npm test`.

#### Prompt

<div  class="ai-response">

**Role:** You are an expert Node.js developer specializing in setting up minimal, functional prototypes. Your goal is to write clean, simple, and effective code that "just works."

**Project Context:** We are building a self-hosted, real-time web game called "Killer." The final product will use Express.js, Socket.IO, and SQLite. This is the absolute first step of development.

**Current Sprint Goal: "The Foundation Vibe"**
Get the bare minimum server running to prove we can serve a simple HTML page and establish a WebSocket connection between the server and a client. This is a smoke test for our core technologies. **We are NOT implementing any game logic, databases, or complex routing at this stage.**

**Technical Constraints & Stack:**

- **Runtime:** Node.js
- **Web Framework:** Express.js
- **Real-Time Library:** Socket.IO
- **Server File:** A single file named `server.js` is preferred for simplicity.
- **Port:** Use port `3000`.
- **Static Files:** The server must serve static files (HTML, JS, CSS) from a directory called `public`.

**Absolute Requirements for this Task:**

1.  Create a project directory and initialize a Node.js project with default settings.
2.  Install the necessary dependencies: `express`, `socket.io`.
3.  Create a `public` folder with a single `index.html` file. The content of this file should be minimal: a heading that says "Killer Game - Lobby" and a paragraph that says "Hello World". This is our placeholder UI.
4.  Create a `server.js` file that:
    - Imports the required modules.
    - Creates an Express app.
    - Serves static files from the `public` directory.
    - Creates an HTTP server from the Express app and binds Socket.IO to it.
    - Listens for Socket.IO `connection` events.
    - When a new client connects, the server must log `"A user connected: [socket.id]"` to the console.
    - Starts the server listening on port `3000`.

**Definition of Done:**
The task is complete when I can:

1.  Run the server using `node server.js`.
2.  Open `http://localhost:3000` in my browser on my development machine and see the "Hello World" message.
3.  See the console log `"A user connected: [socket.id]"` when the page loads.
4.  Open the same URL on another device on my local network (e.g., my phone) by using my machine's local IP address (e.g., `http://192.168.1.50:3000`). Both devices must connect successfully and trigger the connection log on the server.

**Please provide:**

1.  The exact sequence of terminal commands to run (e.g., `mkdir...`, `npm init...`).
2.  The complete code for `server.js`.
3.  The complete code for `public/index.html`.
4.  Clear instructions on how to test the setup on a local network device.

**Remember:** The philosophy is **"The Simplest Thing That Could Possibly Work."** No extra features. No error handling. No organization. Just make it run. We will refactor and expand later.

</div>

#### Conclusion about Deepseek

The firsts steps of building the server using **Deepseek** where really easy and quick to do. But when it got to make the unit tests the results took multiple iterations before resulting into a functionnal code.

### Sprint 1: Enhanced Lobby Vibe

**AI used:** Claude Sonnet 4

#### Setup

1. Clone this repository
2. Run the setup script: `./setup.sh` or `npm run setup`
3. Start the server: `npm start`
4. Open http://localhost:3000 in your browser

**Testing:** to run unit tests do steps 1. and 2. before running `npm test`.

#### Prompt

<div  class="ai-response">

**Role:** You are an expert full-stack Node.js developer. Your task is to extend the existing "Killer" game server from Sprint 0 to implement the complete game creation and player joining flow, using SQLite for persistence and Socket.IO for real-time updates. Key focus is on a flexible, user-friendly joining process and easy game sharing.

**Project Context & State:**

- **You are starting from a working Sprint 0 codebase.** The existing `server.js` serves a static `public/index.html` and establishes a basic Socket.IO connection.
- **Sprint 1 Goal:** Implement the "Lobby Vibe" with revised user flows. A creator can start a game and easily share it. Players can tentatively select and change their identity before finalizing it.

**Technical Constraints & Stack:** (Unchanged)

- **Runtime:** Node.js
- **Web Framework:** Express.js
- **Real-Time Library:** Socket.IO
- **Database:** SQLite with `better-sqlite3`
- **Frontend:** Vanilla JS in HTML files. Use minimal, functional styling.
- **Server File:** Continue using `server.js`.
- **Port:** `3000`

**Revised Requirements & Tasks:**

**1. Database Initialization:** (Mostly Unchanged)

- Modify `server.js` to require and initialize a SQLite database named `database.db`.
- On server start, execute SQL to create the `games` and `players` tables.
- **New Field:** Add a `joined_at` (DATETIME) column to the `players` table to track when a claim is finalized.

**2. Create Game Flow (With Enhanced UX):**

- **Frontend (`public/index.html`):** The form should now have:
  - A textarea for "Player Names".
  - **Two options for tasks:** 1) A textarea for "Tasks". 2) A file input (`<input type="file">`) labeled "Or upload a text file (one task per line)".
  - The "Create Game" button.
- **Backend (`server.js`):** The POST endpoint `/api/create-game` must now:
  - Handle both plain text _and_ a file upload for the task list. Parse the content of the uploaded file (if provided) as plain text, splitting it by newlines to create the task array.
  - **Crucially,** upon successfully creating the game, the response must include the **full, shareable URL** (e.g., `{ gameCode: 'ABCD12', joinUrl: 'http://your-ip:3000/game/ABCD12' }`).
- **New Frontend Behavior:** After creation, `index.html` should display a success message with the `joinUrl`. **This URL must be displayed in a prominent, easily selectable text box (`<input readonly>`) with a "Copy Link" button next to it** to facilitate sharing.

**3. Game Lobby Page & The New Joining Process:**

- **Frontend (`public/game.html`):** The flow for a new player is now a two-step process:
  1.  **Selection Phase:** The page displays the list of players with status `'not-joined'`. Next to each name is a "Select" button.
      - Clicking a "Select" button highlights that choice visually (e.g., changes its background color) on the _client only_. **This action does not communicate with the server yet.**
      - A player can click "Select" on different names; only the last one selected is considered their tentative choice.
      - A "Confirm My Identity" button appears once a name is selected. Also, a "Cancel Selection" button should allow them to clear their choice.
  2.  **Confirmation Phase:** When the user clicks "Confirm My Identity", _then_ the client emits the `claim-identity` event to the server with the chosen name.
- **Backend (Handling `claim-identity`):** Logic remains the same: validate, generate a `session_token`, update the database (`status='alive'`, set `joined_at` to current time), and broadcast the updated player list.
- **New Feature: Cancellation:** For players who have already joined (`status='alive'`), display a "I'm Not [Player Name]" (Cancel) button.
  - Clicking this button emits a new `cancel-identity` event to the server with the `gameCode` and the player's `session_token`.
  - The server handles this:
    - Validates the `session_token` matches the player.
    - Updates the player's record: sets `status` back to `'not-joined'`, and clears the `session_token` and `joined_at`.
    - Broadcasts the updated player list to the entire game room.
  - The client that cancelled should then clear its `session_token` from `localStorage` and revert to the **Selection Phase** view.

**4. Creator Logic & Start Button:** (Unchanged in logic, but the button should be visible and functional based on the new player statuses).

**Definition of Done for This Revised Sprint:**
The task is complete when I can:

1.  Create a game, see a shareable link in a copyable input box, and use a file upload to provide tasks.
2.  Open the game lobby URL on a phone.
3.  **Select one name, then change my mind and select another, all without affecting the server-state.**
4.  Click "Confirm My Identity" to finalize my choice, seeing the lobby update for all users.
5.  Click a "Cancel" button to relinquish my identity, see the lobby update, and be able to choose a different name.
6.  Start the game once all players have finalized their identities.

**Please provide the complete code for:**

1.  The updated `server.js` (including new API endpoint logic, the new `cancel-identity` socket event handler, and file upload handling using a middleware like `express-fileupload` or `multer`).
2.  The updated `public/index.html` (with file upload and link display).
3.  The updated `public/game.html` (with the new multi-step joining interface).
4.  Instructions to install any new NPM packages (e.g., `express-fileupload`).

</div>

#### Conclusion about Claude Sonnet 4

Impressive performances. Code running at first try, even refactored it imediatly when I detailed some UI specifications.
Very user-friendly with its file visualisation feature. Far moreadapted to the code than Deepseek.
